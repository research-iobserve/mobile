Protocom-Extension:
-------------------

Goal: 	Protocom is used to generate code from pcm models. During generation the information which component 
		was generated to which code is necessary to implement the correspondence between observed monitoring data
		on the running system and the corresponding pcm elements. In order to get this information during code-generation
		time, the protocom-extension was developed.
		
		
1. org.palladio.simulator.protocom project:

		1.1 org.palladio.simulator.protocom.extensionpoint.
		
		It is used to implement an eclipse extension point mechanism, in order to provide an extension point to protocom.
		This means: One can use the "standard" eclipse extension point mechanism to provide new extensions to protocom.
		Before this was not possible and one had to download the code-base and introduce new stuff there.
		
		The extension point is described in org.palladiosimulator.protocom/META-INF/MANIFEST.MF file under the 
		section "Extension-Points". The schema is defined in org.palladiosimulator.protocom/schema/protocom.extension.point.exsd.
				
		One example of usage is the org.spp.iobserve.analysis.protocom.rac.extension project. It is an eclipse plug-in
		project which uses the protocom extension point mechanism in order to grasp all possible information of 
		code generation for the purpose described in Goal-section.
		
		o	PcmModelEntityVisitor: Interface used to provide the eclipse extension point mechanism. Implementors
			have to implement this interface to provide an extension.
		o	ProtoComExtensionRegistry: Interface used to specify the registry to manage the extension points.
		o	ProtoComExtensionRegistryImpl: Implementation of ProtoComExtensionRegistry.
		
		
		Where does the ProtoComExtensionRegistry gets called in protocom?
		
		o	org.palladiosimulator.protocom.traverse.framework: PcmRepresentative.store(..)
		At this point, the ProtoComExtensionRegistry gets called and asked for all extension points. It further
		calls the visit(..) method on each extension and passes itself as instance.
		
		More information about Eclipse-Extension-Point-Mechanism:
		- http://www.vogella.com/tutorials/EclipseExtensionPoint/article.html
		- https://wiki.eclipse.org/FAQ_What_are_extensions_and_extension_points%3F
		- http://www.hs-augsburg.de/~meixner/saj/skript/osgi/eclipseplugins.html
		
		
2. org.spp.iobserve.analysis.protocom.rac.extension project:

	Pre-requisites: org.palladio.simulator.protocom has to be installed in eclipse and the extension point described in
	1. has to be available.
	
	2.1 protocom.extension.rac
	This packages contains all necessary files to implement the PcmModelEntityVisitor extension point in order to 
	collect all available information during code-generation for the sake of creating the mapping file used by the
	correspondence model.
	o	PcmMapping, PcmEntity, PcmEntityCorrespondent, PcmOperationSignature and PcmCorrespondentMethod:
		These files represent together the model to marshal and unmarshal the mapping file using Java-JAXB XML mechanism.
		
	More information about JAXB:
	- http://www.vogella.com/tutorials/JAXB/article.html
	- https://docs.oracle.com/javase/tutorial/jaxb/intro/
	- https://de.wikipedia.org/wiki/Java_Architecture_for_XML_Binding
	- http://www.torsten-horn.de/techdocs/java-xml-jaxb.htm
	
	The logic behind the different classes:
	Protocom generates for each component a interface and its implementations along with method signatures. PcmEntity 
	corresponds to such a component. PcmOperationSignatures are all the operations this component provides. 
	PcmCorrespondent is the class containing the information about the generated Java classes and interfaces which 
	realizes the component. PcmCorrespondentMethod are the methods PcmCorrespondnet provides.
	
	Example:
	Let's assume, that TradingSystem.Inventory.Application.Store is a component in the model and it provides an 
	operation called bookSale. And assume further, that BookSale is the class generated by protocom along with the 
	method Get. Hence the mapping.xml could look like:
	
	<PcmMapping>
	    <PcmEntities>
	       <PcmEntity>
	            <Name>TradingSystem.Inventory.Application.Store</Name>
	            <Id>_6tZA5dCmEduC9O_qbthgAg</Id>
	            <OperationSigatures>
	                <OperationSignature>
	                    <Name>bookSale</Name>
	                    <SeffName>bookSale</SeffName>
	                    <Id>_2NKrM1cvEeGI_ZRmqWdpYA</Id>
	                </OperationSignature>
					...                
	            </OperationSigatures>
	            <Correspondents>
	            <Correspondent>
	            		<Comment>Some comment here</Comment>
	                    <FilePath>some path here</FilePath>
	                    <ProjectName>some project name here</ProjectName>
	                    <PackageName>de.kit.ipd.cocome.cloud.serviceadapter.Services</PackageName>
	                    <Interfaces>
	                        <Interface>org.palladiosimulator.protocom.framework.IPerformancePrototypeComponent</Interface>
	                    </Interfaces>
	                    <UnitName>BookSale</UnitName>
	                    <CorrespondentMethods>
	                        <CorrespondentMethod>
	                            <Name>Get</Name>
	                            <ReturnType>void</ReturnType>
	                            <VisibilityModifier></VisibilityModifier>
	                            <Parameters></Parameters>
	                        </CorrespondentMethod>
	                    </CorrespondentMethods>
	                </Correspondent>
	               ...
	           </Correspondents>
	...
	</PcmMapping>
	
	
	o	Activator: since this project is an eclipse plug-in project, we need an activator class to make it available
		for eclipse.
		
	o	RacFileGenerator: Here is where the mapping file gets created. 
		It is an implementation of PcmModelEntityVisitor in order to generate the mapping file. It uses all 
		the Pcm* classes as described.